# Flag is important - 标志位的利用
### 标志位的作用（一）：定时任务与显示任务等

首先要清楚标志位的作用是什么？

在系统设计的文章中有提到过，我们在设计的时候最好不要将请求和业务一起串行执行，比如如果的数据库很大，那么你频繁的查找数据库中的值并更新他们的状态其实是比较麻烦的，比如假设有多个用户，请求了一个比较麻烦的业务，那么他是否需要在页面等你完成？

这个是否我们一般会考虑一种解决方案，就是将他的请求录入数据库，然后运行一个定时任务去集中处理这些任务，如果遇到有问题的就直接记录log即可

那么在上述的这样一个过程中，我们是不可能把这个任务的状态存在内存或者以某种形式存在（这个全看个人领悟）。同时需要注意的事情是**删除数据库的数据是一个非常非常非常危险的事情**，所以一般来说我们会用标志位进行代替

思考一下这样一个场景

我们将修改密码理解为一个特别复杂的任务，他并不能很及时的对客户进行相应。所以客户一般是提出case，然后等待服务器进行处理，并通过邮件等形式返还给他们结果

那么在处理的过程中很有可能会遇到这样的几种状态
1. 未处理
2. 处理中
3. 处理成功
4. 处理异常

那么我们来分析一下标志符：

- 如果没有标志符：如果我们不利用标志位的话，我们需要做的就是将任务读取出来，然后赋予他们标志（这一步可能是在内存中，具体的后面我再进一步学习）。然后在执行过程中依据我们的执行结果，修改对应的标志，并给客户进行结果返还。但是在这个过程中一旦出现了意外，导致多线程中某一个线程出了问题，那么我们是不是就会丢失标志位？这是一个很难以接受的事情，同时先前提到了我们这是一个定时任务，会周期执行，如果不用标志的话，每一次是不是都需要把表中所有任务捞出来？这个时候也许你会说，我们处理成功就会删除记录，先前提到了首先删除是一个危险的动作，其次如果你上一个任务没有执行完，下一个任务再对表进行读取，那么在这个逻辑下是不是就有会有一部分任务重复？同时如果不添加标志符，还会导致用户难以取消等情况

- 因此标志符作用：因此对于这种问题，我们都是考虑这样处理，加入一些删除标志符、取消标志符等，在每一次读取的时候我确实都会读出来未处理的任务，然后进行处理，但是每一次正式开始处理某个任务之前我们都需要确认这个任务是否真的需要处理（例如，取消了或者被之前的线程处理过了）。这就是标志符在这类任务中起到的举足轻重的任务
