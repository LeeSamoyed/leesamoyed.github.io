# MySQL是怎样运行的 从根儿上理解MySQL

## 楔子

## 装作自己是个小白 —— 初识MySQL

### 请求流程

以比较复杂的查询请求为例来展示大致的过程：
- 连接管理
    1. 查询缓存：缓存共享（请求的结果并不会直接销毁，而是会缓存起来，如果不同用户用了同样的命令则会直接共享结果，但是字符匹配很麻烦；同时系统相关、变量函数相关等结果不会存储；值得注意这些缓存对应的表等如果存在修改之类的也会缓存失效，这个是由MySQL的缓存系统直接监视的）
    2. 语法解析
    3. 查询优化：MySQL本身会优化我们的复杂语法（如外连接转化为内连接、表达式简化、子查询转为连接、优化表的查询顺序等等；EXPLAIN语句可以用于查看某个语句的执行计划）
- 解析与优化
- 存储引擎：逻辑概念和物理地址的对应，寻常所写的语句属于server，到了MySQL真的去获取的时候就到了存储引擎层，存储引擎不止一个，它对应了很多很多不同的存储结构，实现不同的功能，采用的存储算法也不同。因此在查询优化之后，就会生成执行计划调用底层存储引擎提供的接口真实的获取数据。值得一提的是server层与存储引擎层的交互，一般以记录为单位。它是一条记录一条记录来判断的。

上述中，server层在判断某条记录符合要求之后，其实是先将其发送到一个缓冲区，待到该缓冲区满了，才向客户端发送真正的记录。该缓冲区大小由系统变量net_buffer_length控制。

## MySQL调控按钮 —— 启动选项和系统变量

## 字符集和比较规则

## 从一条记录说起 —— Inno记录存储结构

## 盛放记录的大盒子 —— InnoDB数据页结构

## 快速查询的秘籍 —— B+树索引

## B+树索引的作用

## 数据的家 —— MySQL的数据目录

## 存放页面的大池子 —— InnoDB的表空间

## 条条大路通罗马 —— 单表访问方法

## 两个表的亲密接触 —— 连接的原理

## 谁最便宜就选谁 —— 基于成本的优化

## 兵马未动，粮草先行 —— InnoDB统计数据是如何收集的

## 基于规则的优化（内含子查询优化二三事）

## 查询优化的百科全书 —— EXPLAIN详解

## 神兵利器 —— optimizer trace的神奇功效

## 调节硬盘和CPU的矛盾 —— InnoDB的Buffer Pool

## 从猫爷借钱说起 —— 事务简介

## 说过的话就一定要做到 —— redo日志

## 后悔了怎么办 —— undo日志

## 一条记录的多幅面孔 —— 事务隔离级别的MVCC

## 工作面试老大难 —— 锁