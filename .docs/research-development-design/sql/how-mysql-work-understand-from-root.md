# MySQL是怎样运行的 从根儿上理解MySQL

## 楔子

## 装作自己是个小白 —— 初识MySQL

### 请求流程

以比较复杂的查询请求为例来展示大致的过程：

- 连接管理
    - 查询缓存：缓存共享（请求的结果并不会直接销毁，而是会缓存起来，如果不同用户用了同样的命令则会直接共享结果，但是字符匹配很麻烦；同时系统相关、变量函数相关等结果不会存储；值得注意这些缓存对应的表等如果存在修改之类的也会缓存失效，这个是由MySQL的缓存系统直接监视的）
    - 语法解析
    - 查询优化：MySQL本身会优化我们的复杂语法（如外连接转化为内连接、表达式简化、子查询转为连接、优化表的查询顺序等等；EXPLAIN语句可以用于查看某个语句的执行计划）

- 解析与优化

- 存储引擎：逻辑概念和物理地址的对应，寻常所写的语句属于server，到了MySQL真的去获取的时候就到了存储引擎层，存储引擎不止一个，它对应了很多很多不同的存储结构，实现不同的功能，采用的存储算法也不同。因此在查询优化之后，就会生成执行计划调用底层存储引擎提供的接口真实的获取数据。值得一提的是server层与存储引擎层的交互，一般以记录为单位。它是一条记录一条记录来判断的。

上述中，server层在判断某条记录符合要求之后，其实是先将其发送到一个缓冲区，待到该缓冲区满了，才向客户端发送真正的记录。该缓冲区大小由系统变量net_buffer_length控制。

## MySQL调控按钮 —— 启动选项和系统变量

- 启动选项，配置文件
- 系统变量
- 状态变量（只能看，不能改）

## 字符集和比较规则

计算机中实际存储的是二进制，显示的是字符串，为了做到这一点需要建立字符串和二进制之间的映射关系。字符到二进制是编码，二进制到字符是解码。

### MySQL字符集

### MySQL比较规则

可能包含多种比较规则（不同国家区分读音等，因此比较规则很多，但是都是以字符集名称+比较偏向命名，例如uft8_polish_ci是波兰语不区分大小写的比较规则）

### MySQL的服务器级别，数据库级别，表级别，列级别字符集和比较规则划分

服务器 > 数据库  > 表 > 列 （每一个都以上一个为默认）

### 字符集转换过程

需要明白的是：客户端在编码请求字符串时实际使用的字符集，与服务器在接收到一个字节序列后认为该字节序列所采用的编码字符集，是两个独立的字符集。

- character_set_client：服务器认为请求是按照该系统变量指定的字符集进行编码的
- character_set_connection：服务器在处理请求时，会把请求字节序列从character_set_client转换为character_set_connection
- character_set_results：服务器采用该系统变量指定的字符集对返回给客户端的字符串进行编码

### 明白

- 客户端发送的请求字节序列是采用哪种字符集进行编码的：这一步骤取决于操作系统当前所使用的字符集（对于Windows系统，还与客户端启动时的设置的启动选项有关）；
- 服务器接受到请求字节序列后会认为它是采用哪种字符集进行编码的：这一步骤取决于系统变量character_set_client的值；
- 服务器在运行过程中会把请求的字节序列转换为以哪种字符集编码的字节序列：这一步骤取决于系统变量character_set_connection的值；
- 服务器在向客户端返回字节序列时，是采用哪种字符集进行编码的：这一步骤取决于系统变量character_set_results的值；
- 客户端在收到响应的字节序列后，是怎么把它们写到命令行窗口中的：这一步骤取决于操作系统当前使用的字符集（对于Windows系统，还与客户端启动时的设置的启动选项有关）；

## 从一条记录说起 —— Inno记录存储结构

Inno在读取数据的时候并不是直接从硬盘读取（读内存比读硬盘快特别多），Inno采取的方式是，将数据划分为若干项，以页作为硬盘和内存之间交互的基本单位。InnoDB中页的大小一般为16KB（这个大小在启动时可以手动设定）。也就是在一般情况下，一次最少从硬盘读取16KB的内容到内存中，一次最少把内存中16KB内容刷新到磁盘中。

### 行格式

- COMPACT
    - 记录的额外信息
        - 变长字段长度列表
        - NULL值列表
        - 记录头信息
            - DB_ROW_ID
            - DB_TRX_ID
            - DB_ROLL_PTR

    - 记录的真实信息
    
    - CHAR(M)列的存储格式

- REDUNDANT

    - 字段长度偏移列表（偏移，就是记录到每个字节总的，现在的偏移减去前一个的偏移就是当前某个字符占据的字节大小）
    - 记录头信息
    - 1byte_offs_flag(表示用几个字节存储偏移量)
    - 没有NULL值表，但是偏移量值的第一个位作为NULL值比特位
    - CHAR(M) 为字符乘以M，例如uft8就是30字节

- 溢出列（如果溢出，就在末尾加指针，真实数据处只会保留部分数据，其余的页地址靠指针）

- DYNAMIC & COMPRESSED行格式

    - DYNAMIC是把所有的真实数据都存储到了溢出页。COMPRESSED相比于DYNAMIC会对也看进行压缩


## 盛放记录的大盒子 —— InnoDB数据页结构

### 记录头信息的属性及描述

|名称|大小（比特）|描述|
|-|-|-|
|预留位1|1|没有使用|
|预留位2|1|没有使用|
|delete_flag|1|表示该记录是否被删除|
|min_rec_flag|1|B+树中每层非叶子节点中的最小的目录项记录都会添加该标记|
|n_owned|4|一个页面中的记录会被分成若干个组，每个组中有一个记录是“带头大哥”，其余的记录都是“小弟”。“带头大哥”记录的n_owned值表示该组中所有记录的条数，“小弟”记录的n_owned值都为0|
|heap_no|13|表示当前记录在页面堆中的相对位置|
|recoed_type|3|表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点的目录项记录，2表示Infimum记录，3表示Supermum记录|
|next_record |16|表示下一条记录的相对位置|

### Infimum & Supermum

对于一个页面来说，虽然Infimum记录和Supermum记录没有主键值，但是InnoDB的设计者规定：Infimum记录是一个页面中最小的记录，Supermum记录是一个页面中最大的记录。

### next_record

- 单项链表，Infimum -> 记录 -> Supermum
- 真实数据的地址：正值向后，负值向前
- 指向的位置是下一个数据的中间某个位置（在指向地址向左读取是信息头，向右读取是真实数据）

### Page Directory

- 槽

- 插入数据
    1. 在初始情况下，两个槽（Infimum&Supermum）
    2. 每插入一条数据都会从页中找到对应记录的主键值比待插入记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
    3. 当一个组中的记录数等于8后，再插入一条记录，会将组中的记录拆分成两个组，其中一个组中4条记录，另一个5条记录。这个拆分过程会在页目录新增一个槽，记录这个新增分组中最大的那条记录的偏移量。

- 快速寻找记录
    * 二分查找法找到槽
    * 遍历槽

### Page Header

主要用于存放存储在数据页中的记录的状态信息（槽数量、记录数量、Free Space再页面中的地址偏移量等）

### File Header

页的通用信息（页的编号，上一页，下一页等）

|名称|描述|
|-|-|
|FIL_PAGE_SPACE_OR_CHECKSUM|校验和|
|FIL_PAGE_OFFSET|页号|
|FIL_PAGE_TYPE|页类型|
|FIL_PAGE_PREV|上一页|
|FIL_PAGE_NEXT|下一页|


### File Trailer

和刷新相关，简单理解为：前四字节内容为检验和（这一部分应该和HEADER中相同，不然认为在刷新中途存在断电现象。后四字节为LSN（这一部分和HEADER中页应该相同）。

### 总结

|名称|描述|大小|
|-|-|-|
|FILE_HEADER|表示页的一些通用信息|38字节|
|PAGE_HEADER|表示数据页专有的一些信息|56字节|
|Infimum&Supermum|两个虚拟的伪记录，分别表示页中的最小记录和最大记录|26字节|
|User Record|真正存储我们插入的记录|大小不固定|
|Free Space|页中尚未使用的部分|大小不固定|
|Page Directory|页中某些记录的相对位置，也就是各个槽对应的记录在页面中的地址偏移量|大小不固定|
|File Trailer|用于检测页是否完整|8字节|

## 快速查询的秘籍 —— B+树索引

### 目录项记录

目录项复用了存储用户记录的数据页的方式来存储目录项（**目录项记录是单独存在一个新的页中不是和普通用户记录存在一起然后靠每个flag区分**）

record_type如果为1，则表明这个是一个目录项记录

目录项只有主键（页的顺序）+页编号（页中用户记录主键最小值）

其中之前记录头中有一个min-rec_flag，只有目录项记录的该值**可能**为1，普通用户记录的这个值都是0

在Page Header部分有一个叫PAGE_LEVEL的属性，它就代表这个数据页作为节点在B+树中的层级

### B+树

如果页有页的目录，页的目录还有页的目录的目录 ...

这样的话，整体就会形成一棵树，B+树

用户记录其实都存放在B+树底层的节点上，这些节点称为叶子节点或叶节点。其余用来存放目录项记录的节点称为非叶子节点或者内节点，其中B+树最上边的那个节点也称为根节点。

!!! warning "槽和层级"
     
     槽对应的是页内记录被分为若干组

     层级对应的是页
    
### 二级索引（辅助索引）

对建立几个B+树，B+树中的数据采用不同的排序规则

回表操作：首先根据二级索引找到对应的主键，在通过主键回到原始表中重新定位完整数据，这个操作叫回表（当然可以每个B+树都存储完整的用户记录，但是太占空间了）

### 联合索引

先按照某一个条件，再按照另一个条件进行排序（多个条件排序）

区别在于，联合只会创建一颗B+树，但是分别为两个条件建立，则会建立两个B+树

### 注意事项

- 对于二级索引记录来说，是先按照二级索引列的值进行排序，在二级索引列值相同的情况下，再按照主键值进行排序。所以，为c2列建立索引其实相当于为(c2, c1)列建立了一个联合索引。另外，对于唯一二级索引（当我们为某个列或列组合声明UNIQUE属性时，便会为这个列或列组合建立唯一二级索引）来说，也可能会出现多条记录键值相同的情况（一是声明为UNIQUE属性的列可能存储多个NULL值，二是我们后面要讲的MVCC服务），唯一二级索引的内节点的目录项记录也会包含记录的主键值。

- 一个页面至少容纳两条记录（防止页面高度增长过快，查询存储等效率降低）

### MyISAM种的索引方案简介

- 将表中的记录按照记录的插入顺序单独存储在一个文件中（称之为数据文件）。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少数据。这样一来，我们可以通过行号快速访问到一条记录。

- MyISAM存储引擎的表会把索引信息单独存储到另一个文件中（称为索引文件）。MyISAM会为表的主键单独创建一个索引，只不过在索引的叶子节点种存储的不是完整的用户记录，而是主键值与行号的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！

- 如果有必要，也可以为其他列分别建立索引或者建立联合索引，其原理与InnoDB中的索引差不多，只不过在叶子节点处存储的是相应的列+行号。这些索引也全部都是二级索引。

### 索引的创建和删除

在数据库中表创建的时候就需要声明是否创建索引，DROP的时候直接ALTER TABLE DROP INDEX就行

## B+树索引的作用

### B+树的优劣

=== "优势"
    查找速度特别快

=== "劣势"
    空间：B+树的索引表会消耗空间

    时间：每次增删改需要修改B+树索引（涉及值的修改、页面分裂、页面回收等）；查询的执行计划（成本分析）等时间可能因为索引过多导致过长

### 应用B+树索引

- 扫描区间

- 条件索引下推 (Index Condition Pushdown, ICP)

- 查询是一门大学问啊！！！P116～P122！！！

- ASC、DESC混用（MySQL8.0引入Descending Index）

- 回表的代价

## 数据的家 —— MySQL的数据目录

## 存放页面的大池子 —— InnoDB的表空间

## 条条大路通罗马 —— 单表访问方法

## 两个表的亲密接触 —— 连接的原理

## 谁最便宜就选谁 —— 基于成本的优化

## 兵马未动，粮草先行 —— InnoDB统计数据是如何收集的

## 基于规则的优化（内含子查询优化二三事）

## 查询优化的百科全书 —— EXPLAIN详解

## 神兵利器 —— optimizer trace的神奇功效

## 调节硬盘和CPU的矛盾 —— InnoDB的Buffer Pool

## 从猫爷借钱说起 —— 事务简介

## 说过的话就一定要做到 —— redo日志

## 后悔了怎么办 —— undo日志

## 一条记录的多幅面孔 —— 事务隔离级别的MVCC

## 工作面试老大难 —— 锁